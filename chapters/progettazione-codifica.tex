\chapter{Progettazione e codifica}
\label{cap:progettazione-codifica}

\intro{In questa sezione vengono descritti tre processi fondamentali nello sviluppo software: la progettazione dell’interfaccia grafica, la realizzazione del PoC e la macro-fase di progettazione architetturale e codifica.}

\section{Mockup dell'interfaccia grafica}
\label{sec:mockup}

\par Durante la progettazione dell’interfaccia grafica, ho tratto ispirazione da diverse soluzioni esistenti analizzate nella fase preliminare. In particolare:
\begin{itemize}
    \item Lo stile delle informazioni in anteprima (come meta keywords, conteggio delle parole, ecc.) si ispira al layout dell’estensione \textit{Detailed SEO Extension}, al quale è stato aggiunto un comportamento flessibile per gestire dinamicamente lo spazio nella barra laterale;
    \item Il box di inserimento della parola chiave è il risultato di una combinazione tra le interfacce di \textit{MozBar} e \textit{Wincher}. Da \textit{MozBar} ho ripreso l’idea della checkbox posizionata sotto il campo di input, che permette di evidenziare una keyword senza dover eseguire preventivamente una ricerca o un’analisi. \textit{Wincher}, invece, ha ispirato il design del campo di testo affiancato da un pulsante per avviare l’analisi;
    \item L’organizzazione delle parole chiave in categorie (user-added keywords, meta keywords, most frequent keywords) si basa su un approccio integrato derivato da strumenti come \textit{Keyword Density Analyzer}, \textit{SEOquake}, \textit{SEOptimer} e \textit{SEO tester online}. Da questi strumenti ho ripreso anche l’idea di una rappresentazione dei risultati in formato tabellare;
    \item Il sistema di filtraggio delle parole chiave - non presente nella prima bozza dell’interfaccia - è stato ispirato da \textit{SEOquake}, che offre funzionalità simili per agevolare la consultazione dei risultati.
\end{itemize}

\vspace{10pt}
\par\noindent Le scelte progettuali sopra elencate sono state accompagnate da un’analisi dello spazio disponibile e delle \textit{best practice} in materia di design, con l’obiettivo di definire fin dalle prime fasi quali elementi utilizzare e come disporli sull’interfaccia per garantire comfort visivo ed evitare il sovraccarico cognitivo. Per la scelta cromatica, il punto di partenza è stato il colore più distintivo, il viola, attorno al quale è stata costruita una combinazione di colori coerente e conforme alle linee guida \gls{wcag}. Questi concetti sono stati infine tradotti in un mockup realizzato con \textit{Figma}.

\begin{figure}[H]
    \centering 
    \includegraphics[width=\columnwidth]{progettazione/mockup.pdf} 
    \caption{Mockup dell'interfaccia grafica}
\end{figure}

\section{PoC}
\label{sec:poc}

\par Lo scopo principale del \gls{poc} è stato quello di tradurre in codice il mockup dell’interfaccia grafica, al fine di verificare la correttezza e la coerenza delle scelte progettuali. Per raggiungere questo obiettivo, ho simulato il funzionamento dell’estensione in ambiente \gls{localhost}, sostituendo una pagina reale con una versione statica. Questa soluzione ha reso possibile lavorare in un ambiente di test controllato, all’interno del quale è stato possibile condurre uno studio di fattibilità e sperimentare le funzionalità di analisi ed evidenziazione visiva delle parole chiave. Al termine di questa fase, è stato organizzato un incontro con la Proponente per discutere i risultati ottenuti e le problematiche riscontrate, e identificare gli elementi da mantenere, modificare o integrare, in vista della successiva progettazione architetturale e dello sviluppo definitivo.

\section{Progettazione architetturale}
\label{sec:progettazione}

\par Il progetto adotta il pattern architetturale MVC (Model-View-Controller) al fine di garantire una chiara separazione delle responsabilità tra i diversi componenti. Questo design pattern prevede tre elementi principali, ciascuno con un ruolo preciso e ben definito:
\begin{itemize}
  \item \textbf{Model}: rappresenta il cuore dell’architettura. È responsabile della rappresentazione e della gestione interna dei dati, isolando le operazioni di manipolazione, archiviazione e accesso. Ha il compito di mantenere i dati organizzati, accurati e coerenti con le regole e la logica dell’applicazione;
  \item \textbf{View}: è il componente con cui l’utente interagisce direttamente. Visualizza i dati in un formato comprensibile e gestisce l’interazione tra l’utente e il sistema. Trattandosi di un componente “passivo”, la View non comunica direttamente con il Model, ma si affida al Controller per elaborare le richieste;
  \item \textbf{Controller}: funge da intermediario tra il Model e la View. Contiene la logica applicativa, elabora le richieste dell’utente e aggiorna il Model e la View di conseguenza. È responsabile della gestione del flusso dell’applicazione.
\end{itemize}

\vspace{5pt}
\par\noindent Il pattern MVC promuove principi fondamentali della qualità del software, quali modularità, manutenibilità, scalabilità, robustezza e riusabilità. La chiara separazione delle responsabilità tra i componenti consente di limitare l’impatto delle modifiche, che possono essere applicate a un singolo modulo senza influire sugli altri. Inoltre, l’architettura MVC facilita l’esecuzione di test di unità e di integrazione, migliorando l’affidabilità del sistema.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=0.6\textwidth]{progettazione/mvc.jpg} 
    \caption{Pattern MVC (Model-View-Controller)}
\end{figure}

\par\noindent Di seguito è riportata la struttura dell'estensione:

\vspace{10pt}
\begin{samepage}
  \dirtree{%
    .1 .github.
    .2 workflows.
    .1 keyword.
    .2 controller.
    .2 model.
    .2 services.
    .3 strategy.
    .2 tests.
    .2 utils.
    .2 view.
    .1 static.
    .2 fonts.
    .2 img.
    .2 libs.
  }
\end{samepage}

\section{Design Pattern}
\label{sec:design-pattern}

\par Oltre al pattern architetturale MVC (Model-View-Controller), ho adottato anche il pattern comportamentale Strategy, che consente di selezionare dinamicamente un algoritmo. Poiché in \textit{JavaScript}, a differenza di linguaggi come \textit{Java} o \textit{C\#}, non esistono interfacce in senso stretto, ho definito una classe che ne simula il comportamento all’interno del design  pattern Strategy. Questa classe agisce come una struttura astratta: impedisce l'istanziazione diretta e impone l’implementazione dei metodi. Nell’ambito del progetto di stage, il pattern Strategy è stato utilizzato per delegare una fase dell’analisi a due classi distinte, ognuna delle quali fornisce una diversa implementazione dello stesso processo. In questo modo è possibile selezionare dinamicamente l’algoritmo desiderato senza modificare il codice del modulo di analisi principale.

\vspace{10pt}
\par\noindent Entrambe le classi calcolano la frequenza complessiva di una keyword tramite la navigazione del \gls{dom} con \textit{TreeWalker}. Le differenze risiedono nel metodo utilizzato per determinare il numero di occorrenze all’interno di un insieme predefinito di tag \gls{html} ritenuti rilevanti per l’analisi. La classe \textit{StagedAnalysisStrategy} esegue un’analisi “per fasi” (staged), contando le occorrenze nei tag solo dopo aver completato il calcolo della frequenza complessiva. L’algoritmo accede direttamente ai tag e ne estrae il contenuto tramite la proprietà \textit{textContent}. Al contrario, la classe \textit{AllInOneAnalysisStrategy} effettua un’analisi compatta e unificata (all in one), registrando le occorrenze nei tag contestualmente al calcolo della frequenza. In questo caso, l’accesso ai tag avviene durante la navigazione del DOM, risalendo la gerarchia (con un approccio bottom-up) ogni volta che viene individuata una corrispondenza all’interno di un nodo.

\section{Elenco delle classi}
\label{sec:elenco-classi}

\subsection{Model}

\par Di seguito sono elencate le classi presenti nella cartella \textit{Model}:

\begin{itemize}
  \item \textbf{Keyword}: rappresenta il modello relativo alle parole chiave. Memorizza il nome (cioè la keyword vera e propria), la frequenza, la densità, lo stato dell’analisi e il numero di occorrenze all’interno di un insieme predefinito di tag \gls{html} considerati rilevanti per l’analisi. Espone metodi getter e setter per l’interazione esterna, oltre a un metodo per ripristinare lo stato del modello e uno per calcolare la densità;
  \item \textbf{KeywordListInfo}: funge da DTO (Data Transfer Object) per la View, trasportando le informazioni associate a una lista di keyword, come la categoria (meta keywords, user-added keywords, ecc.), il titolo, le keyword da visualizzare, il numero totale di pagine e la modalità di ordinamento;
  \item \textbf{OverviewInfo}: memorizza le informazioni relative all’anteprima dell’analisi \gls{seo}, come il contenuto del meta tag \textit{keywords}, la lingua dichiarata nella pagina, il numero totale di parole e il conteggio delle parole uniche.
\end{itemize}

\subsection{View}

\par Di seguito sono elencate le classi presenti nella cartella \textit{View}:

\begin{itemize}
  \item \textbf{KeywordView}: visualizza la dashboard, ovvero il pannello di controllo principale da cui è possibile anche aggiornare l’analisi a livello globale, e gestisce le operazioni di creazione, accesso e rimozione delle sotto-view. La dashboard è suddivisa nelle seguenti sezioni:
  \begin{itemize}
    \item \textbf{Overview}: mostra un’anteprima dell’analisi \gls{seo};
    \item \textbf{Settings}: visualizza le impostazioni dell’analisi SEO, che consentono di personalizzare i colori utilizzati per evidenziare le keyword;
    \item \textbf{Insert Keyword}: mostra un campo di input affiancato da un pulsante per avviare l’analisi. Include anche una checkbox, posizionata sotto il campo di input, che permette di attivare l’evidenziazione della keyword digitata;
    \item \textbf{Keyword List}: visualizza un elenco di keyword organizzate per categoria (meta keywords, user-added keywords, ecc.).
  \end{itemize}
  \item \textbf{KeywordListView}: visualizza una lista di keyword suddivisa in tre sezioni virtuali:
  \begin{itemize}
    \item \textbf{Header}: mostra il titolo della lista, un campo di input per il filtraggio delle keyword, due pulsanti per l’ordinamento e un pulsante per la rimozione dei filtri;
    \item \textbf{Body}: visualizza l’elenco delle keyword, ciascuna accompagnata da un’indicazione della frequenza e un gruppo di pulsanti per l’eliminazione, l’evidenziazione e l’accesso ai risultati dell’analisi;
    \item \textbf{Footer}: mostra l’elenco delle pagine per navigare all’interno della lista delle keyword.
  \end{itemize}
  \item \textbf{AnalysisResultView}: visualizza la sezione con i risultati dell’analisi di una singola keyword, utilizzando un formato tabellare per riportare il numero di occorrenze nei singoli tag \gls{html}. Include anche un pulsante (highlighter) che consente di evidenziare una keyword direttamente e che rimane sincronizzato tra tutte le View.
\end{itemize}

\subsection{Controller}

\par Di seguito sono elencate le classi presenti nella cartella \textit{Controller}:

\begin{itemize}
  \item \textbf{KeywordController}: si occupa dell’inizializzazione e dell’aggiornamento dell’interfaccia, dell’associazione (binding) degli eventi e della gestione delle keyword, includendo funzionalità come inserimento, analisi, evidenziazione, eliminazione, navigazione, ordinamento e filtraggio.
\end{itemize}

\subsection{Services}

\par Di seguito sono elencate le classi presenti nella cartella \textit{Services}:

\begin{itemize}
  \item \textbf{TreeWalkerManager}: gestisce la creazione dell’oggetto \textit{TreeWalker}, definendo quali nodi includere o escludere nella navigazione del \gls{dom}. Fornisce inoltre un metodo per tornare alla radice e uno per accedere al nodo successivo;
  \item \textbf{TextProcessor}: fornisce funzioni di utilità condivise dai moduli di analisi ed evidenziazione. In particolare, espone i seguenti metodi:
  \begin{itemize}
    \item \textbf{getWordsPattern}: restituisce un'espressione regolare per estrarre le parole dal testo;
    \item \textbf{getCompoundSplitPattern}: restituisce un’espressione regolare per suddividere il testo in blocchi (proposizioni);
    \item \textbf{getKeywordPattern}: restituisce un’espressione regolare per identificare una keyword nel testo;
    \item \textbf{getParentName}: restituisce il nome dell’elemento genitore più vicino, risalendo la gerarchia con un approccio bottom-up, tra quelli considerati rilevanti per l’analisi;
    \item \textbf{getTextNodes}: restituisce i nodi di testo;
    \item \textbf{getTextNodeGroups}: restituisce i nodi di testo suddivisi in gruppi. Ciascun gruppo contiene nodi inline validi (ad esempio strong, em, ecc.) che condividono lo stesso elemento genitore.
  \end{itemize}
  \item \textbf{TagAccessor}: centralizza l’accesso ai tag \gls{html} e fornisce un metodo per estrarne il contenuto testuale.
\end{itemize}

\subsection{Utils}

\par Di seguito sono elencate le classi presenti nella cartella \textit{Utils}:

\begin{itemize}
  \item \textbf{Utils}: fornisce due funzioni di utilità, \textit{escapeRegExp} e \textit{escapeHTML}, che consentono rispettivamente di eseguire l’escape di un’espressione regolare e di convertire alcuni caratteri predefiniti in entità \gls{html}. 
\end{itemize}
